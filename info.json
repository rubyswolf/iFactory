{
  "manage": [
    "You can use `ifact list` to list the tools and plugins within the current project.",
    "You can use `ifact templates` to list the available plugin templates provided by iPlug2.",
    "You can create a new plugin within the project by using `ifact create <template> [name]`. The name is the internal code name so it may not contain spaces or special characters."
  ],
  "ui": [
    "iPlug2's UI/graphics framework is IGraphics, and the on-screen UI pieces you attach to it are \"controls,\" i.e., classes that derive from IControl. For more details and advanced features inspect iPlug2/IGraphics.",
    "The interface is created by the `std::function<void(IGraphics* pGraphics)> mLayoutFunc` of your plugin which you assign in the constructor.",
    "The interface will be destroyed if the plugin window is closed but not the DSP rest of the plugin. When reopened the UI is rebuilt so keep in mind that the UI should be initalized into the correct state as changes to controls like disabling and hiding will not persist across the UI rebuild.",
    "Controls are attached to IGraphics within the layout function with `pGraphics->AttachControl(<control>)`.",
    "The most important class within IGraphics is `IRECT` which defines a rectangle within the UI for control bounding boxes.",
    "IRECT has properties `float L, T, R, B` and `W()`/`H()`. While its main constructor is `IRECT(float l, float t, float r, float b)` you'll often want to use `static IRECT MakeXYWH(float l, float t, float w, float h)`",
    "Some controls accept resources such as vector and bitmap images and fonts, you can learn how to import and use resources with `ifact info ui resources`.",
    "You can see a list of available controls and learn more with `ifact info ui controls`."
  ],
  "ui resources": [
    "The available resources are listed at the bottom of config.h of the plugin as macros for the file names of resources.",
    "To add a resource to a plugin you can use `ifact resource add <plugin folder name> <absolute resource path> <resource name in uppercase snake case>`; it will automatically include the resource and add a macro entry like '#define ROBOTO_FN \"Roboto-Regular.ttf\"' (_FN suffix added automatically).",
    "Resources will normally be provided by the user, if the user has not provided the resources they want, let them know they can add resources to a plugin by dragging and dropping a file onto the plugin's sidebar icon or that you can add resources if they provide the path to them.",
    "Fonts are loaded like `pGraphics->LoadFont(\"Roboto-Regular\", ROBOTO_FN)` where the first parameter is the ID.",
    "SVGs are loaded as `const ISVG example = pGraphics->LoadSVG(EXAMPLE_FN)`.",
    "Bitmaps can contian multiple textures stacked side by side as a sprite sheet which is either top to bottom or left to right.",
    "Bitmaps can have multiple scales by having multiple versions with different multipliers at the end using a filename like having example.png and example@2x.png",
    "Bitmaps are loaded with `IBitmap IGraphics::LoadBitmap(const char* fileNameOrResID, int nStates=1, bool framesAreHorizontal=false, int targetScale=0)`.",
    "Use targetScale > 0 to explicity load e.g. an @2x.png"
  ],
  "ui controls": [
    "If you want make a new control outside of what is built into IGraphics or make a modified version of an existing control then you find a tutorial on how to make your own control with `ifact info ui control custom`",
    "Use your Doxygen lookup command to look further into any controls you wish to use or learn from.",
    "Controls are broken into 3 categories based on prefix:",
    "'IV': These these controls render with default builtin vectors, they're functional but often not the prettiest.",
    "'IB': These controls accept provided bitmap images to use for skins, these bitmaps can have multiple textures stacked side by side into a sprite sheet.",
    "'ISVG': These controls accept provided svg vector images to use for skins.",
    "All controls without a prefix don't need a skin image like text controls",
    "# Controls that *can* control parameters",
    "Functional controls link directly to parameters, automatically linking to the parameter and using its label.",
    "However you may link them to kNoParameter.",
    "## Continuous",
    "Knobs: IVKnobControl, IBKnobControl (Sprite sheet), IBKnobRotaterControl (Rotates texture), ISVGKnobControl.",
    "Sliders: IVSliderControl, IBSliderControl, ISVGSliderControl.",
    "Others: IVXYPadControl, IVNumberBoxControl (Very versatile number input with +- buttons, number entry and vertical dragging.), IVRangeSliderControl.",
    "## Discrete:",
    "Toggles (Binary on/off): IVToggleControl, ISVGToggleControl, ITextToggleControl (Uses text as the skin, mainly used with forkawesome, the fork of fontawesome).",
    "Switches (Multi-state, click to increment): IVSwitchControl, IBSwitchControl, ISVGSwitchControl, IVSlideSwitchControl (A click to increment slideswitch (not draggable) with text on the handle for the state)",
    "Others: IVMenuButtonControl (dropdown), IVRadioButtonControl, IVTabSwitchControl (side by side text options using font icons)",
    "# Controls that don't control parameters",
    "Buttons: IVButtonControl, IBButtonControl, ISVGButtonControl. (trigger a provided function when clicked)",
    "Static: IPanelControl (Filled rectangle), IBitmapControl, ISVGControl",
    "Text: `ifact info ui controls text`",
    "Line Plots: IVPlotControl, IVDisplayControl (Rolling history), IVScopeControl (Multi-channel oscilloscope)",
    "Meters: IVMeterControl, IVLEDMeterControl (Segmented LED), IVPeakAvgMeterControl, IBMeterControl (Spritesheet of volume levels)",
    "Spectrum analyzers: IVSpectrumAnalyzerControl, IVBarGraphSpectrumAnalyzerControl",
    "MIDI: IVKeyboardControl, IWheelControl (Pitchbend/Mod wheel)",
    "Preset managers: IVBakedPresetManagerControl, IVDiskPresetManagerControl",
    "Colors: IColorPickerControl, IVColorSwatchControl",
    "Tabs: IVTabbedPagesControl, IVTabPage",
    "Tests: `ifact info ui controls tests`",
    "Custom graphics: IWebViewControl, ILambdaControl (Plays custom animation when clicked), IPlatformViewControl (Embed a HWND, UIView or NSView), ISkLottieControl (Skia Lottie animation via Skottie), IShaderControl (Draw to UI via Skia shading language)",
    "Others: IContainerBase (Allows a control to nest sub controls), IVMultiSliderControl (Editable bar graph), ICornerResizerControl, ILEDControl, IFPSDisplayControl, IPopupMenuControl (The popup list itself for a menu/drop-down), IVGroupControl (Draw rect around named IControl group), IGraphicsLiveEdit (Enables live-edit to rearrange UI)"
  ],
  "ui controls text": [
    "ITextControl, IMultiLineTextControl, IVLabelControl (More fancy and stylable than ITextControl), ISkParagraphControl (Rich text demo with Skia), IBTextControl (Bitmap font from spritesheet), IURLControl, IEditableTextControl, ITextEntryControl, IRTTextControl (Real-time text, can be safely updated from DSP at high rates), ICaptionControl (Displays the textual representation of a parameter), IBubbleControl (Text bubble, good for attaching to sliders to display value next to handle when dragging), PlaceHolder (Placeholder control which is text)"
  ],
  "ui controls tests": [
    "TestAnimationControl, TestArcControl, TestBezierControl, TestBlendControl, TestColorControl, TestCursorControl, TestCustomShaderControl, TestDirBrowseControl, TestDragAndDropControl, TestDrawContextControl, TestDropShadowControl, TestFlexBoxControl, TestFontControl, TestGesturesControl, GFXLabelControl, TestGradientControl, TestImageControl, TestKeyboardControl, TestLayerControl, TestMaskControl, TestMPSControl, TestMultiPathControl, TestMTControl, TestPolyControl, TestShadowGradientControl, TestSizeControl, TestSVGControl, TestTextControl, TestTextOrientationControl, TestTextSizeControl"
  ],
  "ui controls custom": [
    "When creating a custom control you need to make a class that extends IControl included as \"IControl.h\" and use namespace iplug and use namespace igraphics.",
    "Override the draw method for control rendering which takes `IGraphics& g`."
  ],
  "dsp": [
    "Audio runs in `void <Your Plugin>::ProcessBlock(sample** inputs, sample** outputs, int nFrames)` where `sample` is a typedef for double/float depending on the project config.",
    "Useful helpers include `NInChansConnected()` `NOutChansConnected()` and `GetSampleRate()`.",
    "Report processing latency (e.g. for lookahead) with `SetLatency(int samples)`, so the host compensates correctly.",
    "If you need the sample rate then you only need to cache it once in the plugin constructor instead of a more expensive `GetSampleRate()` call within the DSP",
    "This caching philosphy applies everywhere since realtime audio processing needs to be efficient, pre allocate buffers and cache values where possible."
  ],
  "parameter": [
    "When you construct your plugin you extend `iplug::Plugin(info, MakeConfig(kNumParams, kNumPresets))` where you define an enum of parameters in the plugin header.",
    "To get access to a parameter you call `GetParam(int paramIdx)` which you follow by -> to access its methods.",
    "There are a set of Init methods which name and set up how the parameter displays in the DAW.",
    "All continuous initializers are presets for the main initializer `void IParam::InitDouble(const char* name, double defaultVal, double minVal, double maxVal, double step, const char* label, int flags, const char* group, const Shape& shape, EParamUnit unit, DisplayFunc displayFunc)`.",
    "The continuous initializers are InitSeconds, InitMilliseconds, InitGain (dB), InitPercentage and InitAngleDegrees. They all take (const char *name, double defaultVal, double minVal, double maxVal, int flags, const char *group).",
    "The main discrete initializer is `void IParam::InitInt(const char* name, int defaultVal, int minVal, int maxVal, const char* label, int flags, const char* group)`.",
    "Specific values can have their label changed via `void SetDisplayText(double value, const char* str)` e.g. -70dB could display \"-inf\"",
    "Then there is `void IParam::InitEnum(const char* name, int defaultVal, int nEnums, const char* label, int flags, const char* group, const char* listItems, ...)` which is a preset of int which uses SetDisplayText for every value.",
    "The final initializers are presets of Enum. InitPitch takes (const char *name, int defaultVal, int minVal, int maxVal, int flags, const char *group, bool middleCisC4) and uses MIDI pitch numbers 0-127. If middleCisC4 is true uses C4 as middle C, otherwise uses C3.",
    "Finally there is `void IParam::InitBool(const char* name, bool defaultVal, const char* label, int flags, const char* group, const char* offText, const char* onText)`",
    "`Value()` exists to get the readable value of a parameter (say I do InitPercentage, then this is from 0 to 100) but be warned that as tempting as it is, you really shouldn't use it directly within the DSP as calling it is slow.",
    "There is `void <Your Plugin>::OnParamChange(int index)` which you can fill up with a nice big ugly switch statement to change private properties you assign to the plugin itself like `case kDryPercentage: DryFactor = GetParam(kDryPercentage)->Value() / 100` and then use those properties within the DSP to avoid making `Value()` calls all the time.",
    "For additional parameter manipulation inspect iPlug2/IPlug/IPlugParameter.h"
  ],
  "preset": [
    "For presets the easiest way to create them is to just put a list of `void IPluginBase::MakePreset(const char* name, ...)` calls in the constructor after your parameters which creates built-in factory presets, specifying parameter values sequentially.",
    "You can create presets without relying on parameter order using `MakePresetFromNamedParams(const char* name, int nPairs, ...)`.",
    "`nPairs` is the number of (paramIdx, value) pairs that follow. Each pair is `int paramIdx, <value>` where <value> is the parameter's plain/display value (not normalized).",
    "This avoids the fragility of `MakePreset(...)` when parameters are reorderedâ€”because each value is tied to a specific parameter index.",
    "Example:",
    "```c++\n// enum EParams { kBypass, kRate, kDepth, kShape, kNumParams };\n// kRate: 0.1..20.0 Hz, kDepth: 0..24 dB, kShape: 0/1 enum (Sine/Square)\nMakePresetFromNamedParams(\"Subtle Sine\", 3,\n  kRate, 3.0,\n  kDepth, 4.5,\n  kShape, 0);\n\nMakePresetFromNamedParams(\"Too Much\", 2,\n  kRate, 20.0,\n  kDepth, 24.0);\n```",
    "Use integer values for enum parameters, booleans for toggles, and doubles for continuous params. Values should be in the same units you used to initialize the parameter (e.g., Hz, dB, %, seconds).",
    "Tip: keep your parameter indices stable; if indices change between versions, update the preset definitions accordingly.",
    "For more advanced preset creation, inspect iPlug2/IPlug/IPlugPluginBase.h"
  ],
  "serialize": [
    "Serialization is broken into `virtual bool SerializeState(IByteChunk& chunk) const { TRACE return SerializeParams(chunk); }` and `virtual int UnserializeState(const IByteChunk& chunk, int startPos) { TRACE return UnserializeParams(chunk, startPos); }`",
    "By default as you can see they call Serialize and Unserialize Params which are provided below for you to understand how serialization works.",
    "```c++",
    "bool IPluginBase::SerializeParams(IByteChunk& chunk) const",
    "{",
    "  TRACE",
    "  bool savedOK = true;",
    "  int i, n = mParams.GetSize();",
    "  for (i = 0; i < n && savedOK; ++i)",
    "  {",
    "    IParam* pParam = mParams.Get(i);",
    "    Trace(TRACELOC, \"%d %s %f\", i, pParam->GetName(), pParam->Value());",
    "    double v = pParam->Value();",
    "    savedOK &= (chunk.Put(&v) > 0);",
    "  }",
    "  return savedOK;",
    "}",
    "",
    "int IPluginBase::UnserializeParams(const IByteChunk& chunk, int startPos)",
    "{",
    "  TRACE",
    "  int i, n = mParams.GetSize(), pos = startPos;",
    "  ENTER_PARAMS_MUTEX",
    "  for (i = 0; i < n && pos >= 0; ++i)",
    "  {",
    "    IParam* pParam = mParams.Get(i);",
    "    double v = 0.0;",
    "    pos = chunk.Get(&v, pos);",
    "    if (pos >= 0)",
    "    {",
    "      pParam->Set(v);",
    "      Trace(TRACELOC, \"%d %s %f\", i, pParam->GetName(), pParam->Value());",
    "    }",
    "  }",
    "  OnParamReset(kPresetRecall);",
    "  LEAVE_PARAMS_MUTEX",
    "  return pos;",
    "}",
    "```",
    "However there is a huge issue with the builtin parameter serializer, as you can see it just stores a list of values, that means if you ever rearrange the order of parameters or insert new parameters between existing parameters then the wrong values will be assigned to different parameters.",
    "For simple plugins this is normally fine, you just face the limitation that you can only safely add new parameters to the end of the list.",
    "But for any complex system you are highly recommended to override and make a custom serializer that has a version number integer as the first bit of data and update it when adding new data to ensure backwards compatibility so that projects saved using an older version of the plugin can load correctly."
  ]
}
